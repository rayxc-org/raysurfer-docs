---
title: TypeScript SDK
description: "Drop-in replacement for Claude Agent SDK with automatic caching"
---

## Installation

```bash
npm install raysurfer
```

## Setup

Set your API key:

```bash
export RAYSURFER_API_KEY=your_api_key_here
```

Get your key from the [dashboard](https://www.raysurfer.com/dashboard/api-keys).

## Usage

Swap your import — everything else stays the same:

```typescript
// Before
import { query } from "@anthropic-ai/claude-agent-sdk";

// After
import { query } from "raysurfer";

for await (const message of query({
  prompt: "Fetch data from GitHub API",
  options: {
    model: "claude-opus-4-6",
    systemPrompt: "You are a helpful assistant.",
  },
})) {
  console.log(message);
}
```

All Claude SDK types are re-exported from `raysurfer`, so you don't need a
separate import:

```typescript
import {
  query,
  type Options,
  type SDKMessage,
  type Query,
} from "raysurfer";
```

## How It Works

1. **On query**: Retrieves cached code blocks matching your task
2. **Injects into prompt**: Agent sees proven code snippets
3. **After success**: New code is cached for next time

Caching is enabled automatically when `RAYSURFER_API_KEY` is set. Without it,
behaves exactly like the original SDK.

## Class-based API

For users who prefer a class-based interface:

```typescript
import { ClaudeSDKClient } from "raysurfer";

const client = new ClaudeSDKClient({
  model: "claude-opus-4-6",
  systemPrompt: "You are a helpful assistant.",
});

for await (const msg of client.query("Fetch data from GitHub API")) {
  console.log(msg);
}
```

<Note>
  `RaysurferClient` is also exported as an alias for `ClaudeSDKClient` —
  use whichever name you prefer.
</Note>

## System Prompt Preset

Use the Claude Code preset system prompt with appended instructions:

```typescript
for await (const message of query({
  prompt: "Refactor the auth module",
  options: {
    systemPrompt: {
      type: "preset",
      preset: "claude_code",
      append: "Always explain your reasoning.",
    },
  },
})) {
  console.log(message);
}
```

## Query Control Methods

The `query()` function returns a `Query` object with full control methods:

```typescript
const q = query({ prompt: "Build a REST API" });

await q.interrupt();
await q.setPermissionMode("acceptEdits");
await q.setModel("claude-sonnet-4-5-20250929");
await q.setMaxThinkingTokens(4096);
const models = await q.supportedModels();
const info = await q.accountInfo();
q.close();
```

## Snippet Retrieval Scope

Control which cached snippets are retrieved:

```typescript
import { ClaudeSDKClient } from "raysurfer";

// Include company-level snippets (Team/Enterprise)
const client = new ClaudeSDKClient({
  snipsDesired: "company",
});

// Enterprise: client-specific snippets only
const enterpriseClient = new ClaudeSDKClient({
  snipsDesired: "client",
});
```

| Configuration | Required Tier |
|--------------|---------------|
| Default (public only) | FREE |
| `snipsDesired: "company"` | TEAM or ENTERPRISE |
| `snipsDesired: "client"` | ENTERPRISE only |

## Public Snippets

Include community public snippets (crawled from GitHub) alongside your private snippets:

```typescript
// High-level
const client = new ClaudeSDKClient({ publicSnips: true });

// Low-level
const rs = new RaySurfer({ apiKey: "...", publicSnips: true });
```

See [How It Works — Public Snippets](/how-it-works#public-snippets) for details.

## Low-Level API

For custom integrations, use the `RaySurfer` client directly:

```typescript
import { RaySurfer } from "raysurfer";

const client = new RaySurfer({ apiKey: "your_api_key" });

// 1. Search for cached code
const searchResult = await client.search({
  task: "Fetch GitHub trending repos",
});
for (const match of searchResult.matches) {
  console.log(`${match.codeBlock.name}: ${match.combinedScore}`);
}

// 2. Upload a new code file after execution (with dependency versions)
await client.uploadNewCodeSnip({
  task: "Fetch GitHub trending repos",
  fileWritten: { path: "fetch_repos.ts", content: "function fetch() { ... }" },
  succeeded: true,
  dependencies: { "node-fetch": "3.3.0", "zod": "3.22.0" },
});

// 2b. Bulk upload prompts/logs/code for sandboxed grading
await client.uploadBulkCodeSnips(
  ["Build a CLI tool", "Add CSV support"],
  [{ path: "cli.ts", content: "function main() { ... }" }],
  [{ path: "logs/run.log", content: "Task completed", encoding: "utf-8" }],
  true
);

// 3. Vote on whether a cached snippet was useful
await client.voteCodeSnip({
  task: "Fetch GitHub trending repos",
  codeBlockId: "abc123",
  codeBlockName: "github_fetcher",
  codeBlockDescription: "Fetches trending repos from GitHub",
  succeeded: true,
});
```

### Low-Level Client Options

```typescript
const client = new RaySurfer({
  apiKey: "your_api_key",
  baseUrl: "https://api.raysurfer.com", // optional
  timeout: 30000, // optional, in ms
  organizationId: "org_xxx", // optional, for team namespacing
  workspaceId: "ws_xxx", // optional, for enterprise namespacing
  snipsDesired: "company", // optional, snippet scope
  publicSnips: true, // optional, include community snippets
});
```

### Response Fields

The `search()` response includes:

| Field | Type | Description |
|-------|------|-------------|
| `files` | `CodeFile[]` | Retrieved code files with metadata |
| `task` | `string` | The task that was searched |
| `totalFound` | `number` | Total matches found |
| `addToLlmPrompt` | `string` | Pre-formatted string to append to LLM system prompt |

Each `CodeFile` contains:

| Field | Type | Description |
|-------|------|-------------|
| `codeBlockId` | `string` | Unique identifier of the code block |
| `filename` | `string` | Generated filename (e.g., `"github_fetcher.ts"`) |
| `source` | `string` | Full source code |
| `entrypoint` | `string` | Main function to call |
| `description` | `string` | What the code does |
| `inputSchema` | `Record<string, unknown>` | JSON schema for inputs |
| `outputSchema` | `Record<string, unknown>` | JSON schema for outputs |
| `language` | `string` | Programming language |
| `dependencies` | `Record<string, string>` | Package name to version mapping |
| `verdictScore` | `number` | Quality rating (thumbsUp / total, 0.3 if unrated) |
| `thumbsUp` | `number` | Positive votes |
| `thumbsDown` | `number` | Negative votes |
| `similarityScore` | `number` | Semantic similarity (0–1) |
| `combinedScore` | `number` | Combined score (similarity * 0.6 + verdict * 0.4) |

### Search Response

The `search()` method returns a `SearchResponse`:

| Field | Type | Description |
|-------|------|-------------|
| `matches` | `SearchMatch[]` | Matching code blocks with full scoring |
| `totalFound` | `number` | Total matches found |
| `cacheHit` | `boolean` | Whether results were served from cache |
| `searchNamespaces` | `string[]` | Namespaces that were searched |

Each `SearchMatch` contains:

| Field | Type | Description |
|-------|------|-------------|
| `codeBlock` | `CodeBlock` | The code block (has `id`, `name`, `description`, `source`, `entrypoint`, `language`, `dependencies`, `tags`) |
| `combinedScore` | `number` | Overall relevance score (0–1) |
| `vectorScore` | `number` | Semantic similarity score |
| `verdictScore` | `number` | Community quality rating |
| `errorResilience` | `number` | Error handling robustness score |
| `thumbsUp` | `number` | Positive votes |
| `thumbsDown` | `number` | Negative votes |
| `filename` | `string` | Generated filename for the code |
| `language` | `string` | Programming language |
| `entrypoint` | `string` | Main function name |
| `dependencies` | `Record<string, string>` | Package name to version mapping (e.g., `{"node-fetch": "3.3.0"}`) |

### Method Reference

| Method | Description |
|--------|-------------|
| `search({ task, topK?, minVerdictScore?, preferComplete? })` | Search for cached code snippets |
| `uploadNewCodeSnip({ task, fileWritten, succeeded, ... })` | Store a code file for future reuse |
| `uploadBulkCodeSnips({ prompts, filesWritten, ... })` | Bulk upload for grading |
| `voteCodeSnip({ task, codeBlockId, codeBlockName, codeBlockDescription, succeeded })` | Vote on snippet usefulness |
| `tool(name, description, parameters, callback)` | Register a local function as a tool for `execute()` |
| `execute(task, options?)` | Execute a task with registered tools |

## Programmatic Tool Calling

Register local tools and let the server generate + execute code that calls them:

```typescript
import { RaySurfer } from "raysurfer";

const rs = new RaySurfer({ apiKey: "your_api_key" });

rs.tool("add", "Add two numbers", { a: "integer", b: "integer" },
  async (args) => String(Number(args.a) + Number(args.b))
);

rs.tool("multiply", "Multiply two numbers", { a: "integer", b: "integer" },
  async (args) => String(Number(args.a) * Number(args.b))
);

const result = await rs.execute(
  "Add 5 and 3, then multiply the result by 2"
);
console.log(result.result);     // "16"
console.log(result.toolCalls);  // [{toolName: 'add', ...}, ...]
console.log(result.cacheHit);   // true on subsequent runs
```

### How It Works

1. SDK connects a WebSocket to the server for tool call routing
2. Server generates Python code (or reuses reference code from a similar prior run)
3. Code runs in a sandboxed environment — tool calls are routed back to your local functions via WebSocket
4. Results are returned with full tool call history

### Execute Options

```typescript
const result = await rs.execute("Your task description", {
  timeout: 300000,        // Max time in ms (default 300000)
  forceRegenerate: false, // Skip cache (default false)
});
```

### ExecuteResult Fields

| Field | Type | Description |
|-------|------|-------------|
| `executionId` | `string` | Unique execution identifier |
| `result` | `string \| null` | Stdout output from the script |
| `exitCode` | `number` | Process exit code (0 = success) |
| `durationMs` | `number` | Total execution time |
| `cacheHit` | `boolean` | Whether reference code was found from a prior run |
| `error` | `string \| null` | Error message if exitCode != 0 |
| `toolCalls` | `ToolCallRecord[]` | All tool calls made during execution |
