---
title: Tool Compatibility
description: "How to structure your tools for Raysurfer caching"
---

<Warning>
  Raysurfer is designed for agents that generate code and execute it in production. If your agent isn't doing that yet, you need to get onboard! Until then, Raysurfer is not for you.
</Warning>

## The Requirement

For Raysurfer to cache and replay your agent's outputs, **tools must be exposed as functions that can be called directly from code**.

This means your agent's tool implementations should be:
- Pure functions with clear inputs and outputs
- Pure functions with clear, typed inputs and outputs—avoid `unknown`, `any`, or `Dict[str, Any]` types. The more specific your type annotations, the better the agent's code generation will perform.
- Callable without side effects on the LLM context
- Composable into multi-step workflows

## The Ideal Pattern

The best way to understand Raysurfer's value is through this pattern:

```python
llm_input = params
out1 = api1(llm_input)
out2 = function1(out1[2])
out3 = api2(out2.files[-1])
out4 = api3(out3.length)

return out4
```

This is a multi-step workflow where each step depends on the previous step's output. When your agent generates this code:

1. **First run**: The LLM generates this code, executes it, and Raysurfer caches the entire block
2. **Second run**: Raysurfer retrieves the cached code and executes it directly—no token generation needed

## Why Functions Matter

Raysurfer caches the **code** your agent generates, not the raw outputs. For this to work, your tools must be:

| Requirement | Why It Matters |
|-------------|----------------|
| **Callable from code** | Cached code needs to execute the same functions |
| **Deterministic with same inputs** | Replayed code should produce consistent results |
| **Exposed as importable functions** | The generated code needs to reference real functions |
| **Strongly typed** | Specific types help the agent generate correct, reusable code |

## Why Typing Matters

The more specific your type annotations, the better the agent's code generation will perform. Avoid generic types like `unknown`, `any`, `object`, or `Dict[str, Any]`—these force the agent to guess at data structures, leading to brittle code that doesn't cache well.

<CodeGroup>

```python Good - Specific types
from dataclasses import dataclass

@dataclass
class SalesRecord:
    id: str
    amount: float
    quarter: str
    region: str

@dataclass
class Report:
    title: str
    records: list[SalesRecord]
    total: float

def generate_report(records: list[SalesRecord], template: str) -> Report:
    ...
```

```python Bad - Vague types
def generate_report(records: list[dict], template: str) -> dict:
    # Agent doesn't know the shape of records or return value
    ...

def process_data(data: Any) -> Any:
    # Impossible to generate correct downstream code
    ...
```

</CodeGroup>

When types are specific, the agent generates code that correctly accesses fields like `record.amount` instead of guessing with `record["amount"]` or `record.get("amount", 0)`.

## Example: Good vs Bad

<CodeGroup>

```python Good - Functions callable from code
from my_tools import fetch_data, transform, save_result

# Agent generates this code
data = fetch_data(query="quarterly sales")
transformed = transform(data, format="csv")
result = save_result(transformed, path="/reports/q1.csv")
```

```python Bad - Interactive or stateful tools
# Can't cache this - relies on runtime state
response = llm.ask_followup("What format do you want?")
# Can't cache this - side effects in tool execution
tool.execute_with_context(current_session)
```

</CodeGroup>

## Setting Up Your Tools

To make your agent Raysurfer-compatible:

<Steps>
  <Step title="Expose tools as functions">
    Each tool should be a standalone function that takes inputs and returns outputs.
  </Step>
  <Step title="Make inputs explicit">
    All data the function needs should come from parameters, not global state.
  </Step>
  <Step title="Return structured outputs">
    Functions should return data that can be passed to subsequent function calls.
  </Step>
</Steps>

## Real-World Example

Here's a practical example of a Raysurfer-compatible agent workflow:

```python
from data_tools import query_database, filter_records, generate_report, send_email

# This entire block gets cached and replayed
records = query_database(table="sales", quarter="Q1")
filtered = filter_records(records, min_value=10000)
report = generate_report(filtered, template="executive_summary")
result = send_email(report, recipients=["team@company.com"])

return result
```

When the same query pattern is detected, Raysurfer retrieves this code block and executes it directly—skipping token generation entirely.
