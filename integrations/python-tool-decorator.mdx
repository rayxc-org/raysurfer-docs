---
title: Python Tool Decorator
description: "Use @rs.tool to expose local Python functions for programmatic tool calling in Raysurfer sandbox execution"
---

The Python tool decorator integration lets you expose local functions as tools and run generated code in a remote sandbox with tool calls routed back to your app.

<Note>
  Source: [rayxc-org/raysurfer-python](https://github.com/rayxc-org/raysurfer-python)
</Note>

## Setup

Install the SDK and set `RAYSURFER_API_KEY` in your environment.

```bash
pip install raysurfer
```

## Register Tools

`@rs.tool` can wrap any Python function. The function signature is converted to schema fields, and the function docstring is used as the tool description in the tool payload.

```python
from raysurfer import AsyncRaySurfer

rs = AsyncRaySurfer(api_key="your_api_key")

@rs.tool
def add(a: int, b: int) -> int:
    """Add two numbers."""
    return a + b
```

## Execute Modes

Use exactly one mode per `execute()` call:

### Primary Mode: Pass `user_code`

```python
result = await rs.execute(
    "Compute 5 + 3",
    user_code="print(add(5, 3))",
)
```

### Optional Mode: Sandbox Codegen

In this mode, code is generated inside the Daytona sandbox from your prompt.

```python
result = await rs.execute(
    "Compute 5 + 3",
    codegen_api_key="YOUR_ANTHROPIC_API_KEY",
    codegen_prompt="Write Python code that calls add(a, b) for 5 and 3, then prints the result.",
    codegen_model="claude-opus-4-6",
)
```

## Full SDK Reference

See [Python SDK](/sdk/python#programmatic-tool-calling) for full method signatures and response fields.
