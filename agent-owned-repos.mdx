---
title: Agent-Owned Repos
description: "How agents build up a library of proven code over time"
---

# Agent-Owned Repos

## What This Means

An agent-owned repo is the idea that agents can build up a library of proven code over time, based on execution results rather than one-off code generation.

Instead of generating from scratch every run, agents:

1. **Search** for proven code that already solved similar tasks
2. **Execute** the code in an isolated sandbox environment
3. **Score** the results — code that produces useful output gets promoted
4. **Build a library** — over time, the agent accumulates a growing collection of reliable code

## The Core Loop

```
Search proven code → Execute → Score → Promote top patterns
```

This makes agent behavior more stable over time. Agents start from high-signal code paths and only generate new code when necessary.

## How Raysurfer Supports This

Raysurfer combines three things to make agent-owned repos work:

- **Proven code retrieval** — semantic search finds code that already worked for similar tasks, so agents reuse instead of regenerate
- **Reputation scoring** — every snippet earns a score through execution results and user feedback (`thumbs_up` / `thumbs_down`), so the best code rises to the top
- **Reuse-first workflows** — SDKs and integrations search the cache before generating, making retrieval the default path

## Sandbox Execution

When agents execute code through Raysurfer, it runs in an isolated environment. This means:

- Code runs safely without affecting your production systems
- Execution results are captured and used for reputation scoring
- Failed code is automatically excluded from future retrieval

## Persistent Code Library

Published functions stay available across sessions. When you publish functions via `publish_function_registry` (Python) or `publishFunctionRegistry` (TypeScript), they're stored and accessible for future agent sessions within the same org/workspace scope.

This means agents don't need to re-upload functions each session — proven code persists and is available across runs. See the [Function Registry](/integrations/function-registry) for setup details.

## Recommended Rollout

1. Add Raysurfer to one high-frequency workflow first.
2. Track which snippets are repeatedly reused with positive votes.
3. Expand to additional workflows once retrieval quality is stable.

<Note>
Keep values parameterized in snippets. Hardcode only values you expect to be reused verbatim.
</Note>

<Card title="Need help planning your rollout?" icon="calendar" href="https://calendly.com/raymond-raysurfer/15min">
  Book a 15-minute call and we'll help you pick the right workflows to start with.
</Card>

<CardGroup cols={2}>
  <Card title="Code Reputation Registry" icon="chart-line" href="https://www.raysurfer.com/public_snippets">
    Inspect publicly ranked snippets and quality signals that feed reuse decisions.
  </Card>
  <Card title="How It Works" icon="gear" href="/how-it-works">
    Learn about proven code retrieval and reputation scoring.
  </Card>
  <Card title="Integrations" icon="plug" href="/integrations/overview">
    Add the same loop through Python/TypeScript SDKs, CLI, MCP, skill, or plugin.
  </Card>
  <Card title="Results" icon="chart-bar" href="/results">
    See real-world accuracy and speed improvements.
  </Card>
</CardGroup>
