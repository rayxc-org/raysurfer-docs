---
title: Introduction
description: "Semantic code caching for AI agents"
---

# What is Raysurfer?

Raysurfer is semantic code caching for AI agents. When your agent
generates and executes code, Raysurfer caches it. When a similar task comes
up, your agent retrieves and runs the cached code instead of regenerating.

<CardGroup cols={2}>
  <Card title="30x Faster" icon="bolt">
    Cache hits return in ~1s vs 30-180s of code generation
  </Card>
  <Card title="Drop-in Replacement" icon="plug">
    One import change. Same API. Works with your existing Claude Agent SDK code.
  </Card>
  <Card title="Lower Variance" icon="chart-line">
    Run proven code that already worked, not fresh generation rolls
  </Card>
  <Card title="Verdict Scoring" icon="check-circle">
    Track what succeeded vs failed. Good code rises, bad code sinks.
  </Card>
</CardGroup>

## The Problem

Every time your agent runs, you wait for tokens to generate. The same
patterns. The same outputs. Every. Single. Time.

You're paying for tokens. You're waiting for generation. For code that's
already been generated somewhere else.

## The Solution

Raysurfer retrieves and runs proven code from previous executions. No waiting.
No regenerating. Just execute.

```
Generate once, run forever.
```

<Note>
Raysurfer's value kicks in when you ask a query **similar** to a previous
oneâ€”not just identical. Semantic matching finds related patterns, so "fetch
GitHub repos" and "get trending GitHub projects" can both hit the same cached
code.
</Note>

## How It Works

1. **Cache generated code** â€” When your agent writes and runs code, it's
   cached with semantic embeddings
2. **Retrieve by task** â€” Describe what you need in natural language. Hybrid
   search finds relevant cached code.
3. **Verdict-aware scoring** â€” Code that works gets ğŸ‘, code that fails gets
   ğŸ‘. Retrieval improves over time.

<Card title="Ready to get started?" icon="rocket" href="/quickstart">
  Follow our quickstart guide to integrate Raysurfer in under 5 minutes
</Card>
